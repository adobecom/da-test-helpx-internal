/* eslint-disable */
/* PrismJS 1.29.0
https://prismjs.com/download.html#themes=prism-coy&languages=markup+css+clike+javascript+markup-templating+php+sql&plugins=line-highlight+line-numbers+keep-markup+normalize-whitespace+toolbar+copy-to-clipboard */
const initPrism = () => {
  /* PrismJS 1.29.0
    https://prismjs.com/download.html#themes=prism-coy&languages=markup+css+clike+markup-templating+php+sql&plugins=line-numbers+keep-markup+normalize-whitespace+toolbar+copy-to-clipboard */
  const _self = typeof window !== 'undefined' ? window : typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope ? self : {}; const Prism = (function (e) {
    const n = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i; let t = 0; const r = {}; var a = {
      manual: e.Prism && e.Prism.manual,
      disableWorkerMessageHandler: e.Prism && e.Prism.disableWorkerMessageHandler,
      util: {
        encode: function e(n) { return n instanceof i ? new i(n.type, e(n.content), n.alias) : Array.isArray(n) ? n.map(e) : n.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' '); }, type(e) { return Object.prototype.toString.call(e).slice(8, -1); }, objId(e) { return e.__id || Object.defineProperty(e, '__id', { value: ++t }), e.__id; }, clone: function e(n, t) { let r; let i; switch (t = t || {}, a.util.type(n)) { case 'Object': if (i = a.util.objId(n), t[i]) return t[i]; for (const l in r = {}, t[i] = r, n)n.hasOwnProperty(l) && (r[l] = e(n[l], t)); return r; case 'Array': return i = a.util.objId(n), t[i] ? t[i] : (r = [], t[i] = r, n.forEach(((n, a) => { r[a] = e(n, t); })), r); default: return n; } }, getLanguage(e) { for (;e;) { const t = n.exec(e.className); if (t) return t[1].toLowerCase(); e = e.parentElement; } return 'none'; }, setLanguage(e, t) { e.className = e.className.replace(RegExp(n, 'gi'), ''), e.classList.add(`language-${t}`); }, currentScript() { if (typeof document === 'undefined') return null; if ('currentScript' in document) return document.currentScript; try { throw new Error(); } catch (r) { const e = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(r.stack) || [])[1]; if (e) { const n = document.getElementsByTagName('script'); for (const t in n) if (n[t].src == e) return n[t]; } return null; } }, isActive(e, n, t) { for (let r = `no-${n}`; e;) { const a = e.classList; if (a.contains(n)) return !0; if (a.contains(r)) return !1; e = e.parentElement; } return !!t; },
      },
      languages: {
        plain: r, plaintext: r, text: r, txt: r, extend(e, n) { const t = a.util.clone(a.languages[e]); for (const r in n)t[r] = n[r]; return t; }, insertBefore(e, n, t, r) { const i = (r = r || a.languages)[e]; const l = {}; for (const o in i) if (i.hasOwnProperty(o)) { if (o == n) for (const s in t)t.hasOwnProperty(s) && (l[s] = t[s]); t.hasOwnProperty(o) || (l[o] = i[o]); } const u = r[e]; return r[e] = l, a.languages.DFS(a.languages, (function (n, t) { t === u && n != e && (this[n] = l); })), l; }, DFS: function e(n, t, r, i) { i = i || {}; const l = a.util.objId; for (const o in n) if (n.hasOwnProperty(o)) { t.call(n, o, n[o], r || o); const s = n[o]; const u = a.util.type(s); u !== 'Object' || i[l(s)] ? u !== 'Array' || i[l(s)] || (i[l(s)] = !0, e(s, t, o, i)) : (i[l(s)] = !0, e(s, t, null, i)); } },
      },
      plugins: {},
      highlightAll(e, n) { a.highlightAllUnder(document, e, n); },
      highlightAllUnder(e, n, t) { const r = { callback: t, container: e, selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code' }; a.hooks.run('before-highlightall', r), r.elements = Array.prototype.slice.apply(r.container.querySelectorAll(r.selector)), a.hooks.run('before-all-elements-highlight', r); for (var i, l = 0; i = r.elements[l++];)a.highlightElement(i, !0 === n, r.callback); },
      highlightElement(n, t, r) { const i = a.util.getLanguage(n); const l = a.languages[i]; a.util.setLanguage(n, i); let o = n.parentElement; o && o.nodeName.toLowerCase() === 'pre' && a.util.setLanguage(o, i); const s = { element: n, language: i, grammar: l, code: n.textContent }; function u(e) { s.highlightedCode = e, a.hooks.run('before-insert', s), s.element.innerHTML = s.highlightedCode, a.hooks.run('after-highlight', s), a.hooks.run('complete', s), r && r.call(s.element); } if (a.hooks.run('before-sanity-check', s), (o = s.element.parentElement) && o.nodeName.toLowerCase() === 'pre' && !o.hasAttribute('tabindex') && o.setAttribute('tabindex', '0'), !s.code) return a.hooks.run('complete', s), void (r && r.call(s.element)); if (a.hooks.run('before-highlight', s), s.grammar) if (t && e.Worker) { const c = new Worker(a.filename); c.onmessage = function (e) { u(e.data); }, c.postMessage(JSON.stringify({ language: s.language, code: s.code, immediateClose: !0 })); } else u(a.highlight(s.code, s.grammar, s.language)); else u(a.util.encode(s.code)); },
      highlight(e, n, t) { const r = { code: e, grammar: n, language: t }; if (a.hooks.run('before-tokenize', r), !r.grammar) throw new Error(`The language "${r.language}" has no grammar.`); return r.tokens = a.tokenize(r.code, r.grammar), a.hooks.run('after-tokenize', r), i.stringify(a.util.encode(r.tokens), r.language); },
      tokenize(e, n) { const t = n.rest; if (t) { for (const r in t)n[r] = t[r]; delete n.rest; } const a = new s(); return u(a, a.head, e), o(e, a, n, a.head, 0), (function (e) { for (var n = [], t = e.head.next; t !== e.tail;)n.push(t.value), t = t.next; return n; }(a)); },
      hooks: { all: {}, add(e, n) { const t = a.hooks.all; t[e] = t[e] || [], t[e].push(n); }, run(e, n) { const t = a.hooks.all[e]; if (t && t.length) for (var r, i = 0; r = t[i++];)r(n); } },
      Token: i,
    }; function i(e, n, t, r) { this.type = e, this.content = n, this.alias = t, this.length = 0 | (r || '').length; } function l(e, n, t, r) { e.lastIndex = n; const a = e.exec(t); if (a && r && a[1]) { const i = a[1].length; a.index += i, a[0] = a[0].slice(i); } return a; } function o(e, n, t, r, s, g) { for (const f in t) if (t.hasOwnProperty(f) && t[f]) { let h = t[f]; h = Array.isArray(h) ? h : [h]; for (let d = 0; d < h.length; ++d) { if (g && g.cause == `${f},${d}`) return; const v = h[d]; const p = v.inside; const m = !!v.lookbehind; const y = !!v.greedy; const k = v.alias; if (y && !v.pattern.global) { const x = v.pattern.toString().match(/[imsuy]*$/)[0]; v.pattern = RegExp(v.pattern.source, `${x}g`); } for (let b = v.pattern || v, w = r.next, A = s; w !== n.tail && !(g && A >= g.reach); A += w.value.length, w = w.next) { let E = w.value; if (n.length > e.length) return; if (!(E instanceof i)) { var P; let L = 1; if (y) { if (!(P = l(b, A, e, m)) || P.index >= e.length) break; var S = P.index; const O = P.index + P[0].length; let j = A; for (j += w.value.length; S >= j;)j += (w = w.next).value.length; if (A = j -= w.value.length, w.value instanceof i) continue; for (let C = w; C !== n.tail && (j < O || typeof C.value === 'string'); C = C.next)L++, j += C.value.length; L--, E = e.slice(A, j), P.index -= A; } else if (!(P = l(b, 0, E, m))) continue; S = P.index; const N = P[0]; const _ = E.slice(0, S); const M = E.slice(S + N.length); const W = A + E.length; g && W > g.reach && (g.reach = W); let z = w.prev; if (_ && (z = u(n, z, _), A += _.length), c(n, z, L), w = u(n, z, new i(f, p ? a.tokenize(N, p) : N, k, N)), M && u(n, w, M), L > 1) { const I = { cause: `${f},${d}`, reach: W }; o(e, n, t, w.prev, A, I), g && I.reach > g.reach && (g.reach = I.reach); } } } } } } function s() { const e = { value: null, prev: null, next: null }; const n = { value: null, prev: e, next: null }; e.next = n, this.head = e, this.tail = n, this.length = 0; } function u(e, n, t) { const r = n.next; const a = { value: t, prev: n, next: r }; return n.next = a, r.prev = a, e.length++, a; } function c(e, n, t) { for (var r = n.next, a = 0; a < t && r !== e.tail; a++)r = r.next; n.next = r, r.prev = n, e.length -= a; } if (e.Prism = a, i.stringify = function e(n, t) {
      if (typeof n === 'string') return n; if (Array.isArray(n)) { let r = ''; return n.forEach(((n) => { r += e(n, t); })), r; } const i = {
        type: n.type, content: e(n.content, t), tag: 'span', classes: ['token', n.type], attributes: {}, language: t,
      }; const l = n.alias; l && (Array.isArray(l) ? Array.prototype.push.apply(i.classes, l) : i.classes.push(l)), a.hooks.run('wrap', i); let o = ''; for (const s in i.attributes)o += ` ${s}="${(i.attributes[s] || '').replace(/"/g, '&quot;')}"`; return `<${i.tag} class="${i.classes.join(' ')}"${o}>${i.content}</${i.tag}>`;
    }, !e.document) return e.addEventListener ? (a.disableWorkerMessageHandler || e.addEventListener('message', ((n) => { const t = JSON.parse(n.data); const r = t.language; const i = t.code; const l = t.immediateClose; e.postMessage(a.highlight(i, a.languages[r], r)), l && e.close(); }), !1), a) : a; const g = a.util.currentScript(); function f() { a.manual || a.highlightAll(); } if (g && (a.filename = g.src, g.hasAttribute('data-manual') && (a.manual = !0)), !a.manual) { const h = document.readyState; h === 'loading' || h === 'interactive' && g && g.defer ? document.addEventListener('DOMContentLoaded', f) : window.requestAnimationFrame ? window.requestAnimationFrame(f) : window.setTimeout(f, 16); } return a;
  }(_self)); typeof module !== 'undefined' && module.exports && (module.exports = Prism), typeof global !== 'undefined' && (global.Prism = Prism);
  Prism.languages.markup = {
    comment: { pattern: /<!--(?:(?!<!--)[\s\S])*?-->/, greedy: !0 }, prolog: { pattern: /<\?[\s\S]+?\?>/, greedy: !0 }, doctype: { pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i, greedy: !0, inside: { 'internal-subset': { pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/, lookbehind: !0, greedy: !0, inside: null }, string: { pattern: /"[^"]*"|'[^']*'/, greedy: !0 }, punctuation: /^<!|>$|[[\]]/, 'doctype-tag': /^DOCTYPE/i, name: /[^\s<>'"]+/ } }, cdata: { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, greedy: !0 }, tag: { pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/, greedy: !0, inside: { tag: { pattern: /^<\/?[^\s>\/]+/, inside: { punctuation: /^<\/?/, namespace: /^[^\s>\/:]+:/ } }, 'special-attr': [], 'attr-value': { pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/, inside: { punctuation: [{ pattern: /^=/, alias: 'attr-equals' }, { pattern: /^(\s*)["']|["']$/, lookbehind: !0 }] } }, punctuation: /\/?>/, 'attr-name': { pattern: /[^\s>\/]+/, inside: { namespace: /^[^\s>\/:]+:/ } } } }, entity: [{ pattern: /&[\da-z]{1,8};/i, alias: 'named-entity' }, /&#x?[\da-f]{1,8};/i],
  }, Prism.languages.markup.tag.inside['attr-value'].inside.entity = Prism.languages.markup.entity, Prism.languages.markup.doctype.inside['internal-subset'].inside = Prism.languages.markup, Prism.hooks.add('wrap', ((a) => { a.type === 'entity' && (a.attributes.title = a.content.replace(/&amp;/, '&')); })), Object.defineProperty(Prism.languages.markup.tag, 'addInlined', { value(a, e) { const s = {}; s[`language-${e}`] = { pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i, lookbehind: !0, inside: Prism.languages[e] }, s.cdata = /^<!\[CDATA\[|\]\]>$/i; const t = { 'included-cdata': { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, inside: s } }; t[`language-${e}`] = { pattern: /[\s\S]+/, inside: Prism.languages[e] }; const n = {}; n[a] = { pattern: RegExp('(<__[^>]*>)(?:<!\\[CDATA\\[(?:[^\\]]|\\](?!\\]>))*\\]\\]>|(?!<!\\[CDATA\\[)[^])*?(?=</__>)'.replace(/__/g, (() => a)), 'i'), lookbehind: !0, greedy: !0, inside: t }, Prism.languages.insertBefore('markup', 'cdata', n); } }), Object.defineProperty(Prism.languages.markup.tag, 'addAttribute', { value(a, e) { Prism.languages.markup.tag.inside['special-attr'].push({ pattern: RegExp(`(^|["'\\s])(?:${a})\\s*=\\s*(?:"[^"]*"|'[^']*'|[^\\s'">=]+(?=[\\s>]))`, 'i'), lookbehind: !0, inside: { 'attr-name': /^[^\s=]+/, 'attr-value': { pattern: /=[\s\S]+/, inside: { value: { pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/, lookbehind: !0, alias: [e, `language-${e}`], inside: Prism.languages[e] }, punctuation: [{ pattern: /^=/, alias: 'attr-equals' }, /"|'/] } } } }); } }), Prism.languages.html = Prism.languages.markup, Prism.languages.mathml = Prism.languages.markup, Prism.languages.svg = Prism.languages.markup, Prism.languages.xml = Prism.languages.extend('markup', {}), Prism.languages.ssml = Prism.languages.xml, Prism.languages.atom = Prism.languages.xml, Prism.languages.rss = Prism.languages.xml;
  !(function (s) {
    const e = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/; s.languages.css = {
      comment: /\/\*[\s\S]*?\*\//, atrule: { pattern: RegExp(`@[\\w-](?:[^;{\\s"']|\\s+(?!\\s)|${e.source})*?(?:;|(?=\\s*\\{))`), inside: { rule: /^@[\w-]+/, 'selector-function-argument': { pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/, lookbehind: !0, alias: 'selector' }, keyword: { pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/, lookbehind: !0 } } }, url: { pattern: RegExp(`\\burl\\((?:${e.source}|(?:[^\\\\\r\n()"']|\\\\[^])*)\\)`, 'i'), greedy: !0, inside: { function: /^url/i, punctuation: /^\(|\)$/, string: { pattern: RegExp(`^${e.source}$`), alias: 'url' } } }, selector: { pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|${e.source})*(?=\\s*\\{)`), lookbehind: !0 }, string: { pattern: e, greedy: !0 }, property: { pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i, lookbehind: !0 }, important: /!important\b/i, function: { pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i, lookbehind: !0 }, punctuation: /[(){};:,]/,
    }, s.languages.css.atrule.inside.rest = s.languages.css; const t = s.languages.markup; t && (t.tag.addInlined('style', 'css'), t.tag.addAttribute('style', 'css'));
  }(Prism));
  Prism.languages.clike = {
    comment: [{ pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: !0, greedy: !0 }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: !0, greedy: !0 }], string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: !0 }, 'class-name': { pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i, lookbehind: !0, inside: { punctuation: /[.\\]/ } }, keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/, boolean: /\b(?:false|true)\b/, function: /\b\w+(?=\()/, number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i, operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/, punctuation: /[{}[\];(),.:]/,
  };
  !(function (e) { function n(e, n) { return `___${e.toUpperCase()}${n}___`; }Object.defineProperties(e.languages['markup-templating'] = {}, { buildPlaceholders: { value(t, a, r, o) { if (t.language === a) { const c = t.tokenStack = []; t.code = t.code.replace(r, ((e) => { if (typeof o === 'function' && !o(e)) return e; for (var r, i = c.length; t.code.indexOf(r = n(a, i)) !== -1;)++i; return c[i] = e, r; })), t.grammar = e.languages.markup; } } }, tokenizePlaceholders: { value(t, a) { if (t.language === a && t.tokenStack) { t.grammar = e.languages[a]; let r = 0; const o = Object.keys(t.tokenStack); !(function c(i) { for (let u = 0; u < i.length && !(r >= o.length); u++) { const g = i[u]; if (typeof g === 'string' || g.content && typeof g.content === 'string') { const l = o[r]; const s = t.tokenStack[l]; const f = typeof g === 'string' ? g : g.content; const p = n(a, l); const k = f.indexOf(p); if (k > -1) { ++r; const m = f.substring(0, k); const d = new e.Token(a, e.tokenize(s, t.grammar), `language-${a}`, s); const h = f.substring(k + p.length); const v = []; m && v.push.apply(v, c([m])), v.push(d), h && v.push.apply(v, c([h])), typeof g === 'string' ? i.splice.apply(i, [u, 1].concat(v)) : g.content = v; } } else g.content && c(g.content); } return i; }(t.tokens)); } } } }); }(Prism));
  !(function (e) {
    const a = /\/\*[\s\S]*?\*\/|\/\/.*|#(?!\[).*/; const t = [{ pattern: /\b(?:false|true)\b/i, alias: 'boolean' }, { pattern: /(::\s*)\b[a-z_]\w*\b(?!\s*\()/i, greedy: !0, lookbehind: !0 }, { pattern: /(\b(?:case|const)\s+)\b[a-z_]\w*(?=\s*[;=])/i, greedy: !0, lookbehind: !0 }, /\b(?:null)\b/i, /\b[A-Z_][A-Z0-9_]*\b(?!\s*\()/]; const i = /\b0b[01]+(?:_[01]+)*\b|\b0o[0-7]+(?:_[0-7]+)*\b|\b0x[\da-f]+(?:_[\da-f]+)*\b|(?:\b\d+(?:_\d+)*\.?(?:\d+(?:_\d+)*)?|\B\.\d+)(?:e[+-]?\d+)?/i; const n = /<?=>|\?\?=?|\.{3}|\??->|[!=]=?=?|::|\*\*=?|--|\+\+|&&|\|\||<<|>>|[?~]|[/^|%*&<>.+-]=?/; const s = /[{}\[\](),:;]/; e.languages.php = {
      delimiter: { pattern: /\?>$|^<\?(?:php(?=\s)|=)?/i, alias: 'important' }, comment: a, variable: /\$+(?:\w+\b|(?=\{))/, package: { pattern: /(namespace\s+|use\s+(?:function\s+)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i, lookbehind: !0, inside: { punctuation: /\\/ } }, 'class-name-definition': { pattern: /(\b(?:class|enum|interface|trait)\s+)\b[a-z_]\w*(?!\\)\b/i, lookbehind: !0, alias: 'class-name' }, 'function-definition': { pattern: /(\bfunction\s+)[a-z_]\w*(?=\s*\()/i, lookbehind: !0, alias: 'function' }, keyword: [{ pattern: /(\(\s*)\b(?:array|bool|boolean|float|int|integer|object|string)\b(?=\s*\))/i, alias: 'type-casting', greedy: !0, lookbehind: !0 }, { pattern: /([(,?]\s*)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|object|self|static|string)\b(?=\s*\$)/i, alias: 'type-hint', greedy: !0, lookbehind: !0 }, { pattern: /(\)\s*:\s*(?:\?\s*)?)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|never|object|self|static|string|void)\b/i, alias: 'return-type', greedy: !0, lookbehind: !0 }, { pattern: /\b(?:array(?!\s*\()|bool|float|int|iterable|mixed|object|string|void)\b/i, alias: 'type-declaration', greedy: !0 }, { pattern: /(\|\s*)(?:false|null)\b|\b(?:false|null)(?=\s*\|)/i, alias: 'type-declaration', greedy: !0, lookbehind: !0 }, { pattern: /\b(?:parent|self|static)(?=\s*::)/i, alias: 'static-context', greedy: !0 }, { pattern: /(\byield\s+)from\b/i, lookbehind: !0 }, /\bclass\b/i, { pattern: /((?:^|[^\s>:]|(?:^|[^-])>|(?:^|[^:]):)\s*)\b(?:abstract|and|array|as|break|callable|case|catch|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|enum|eval|exit|extends|final|finally|fn|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|match|namespace|never|new|or|parent|print|private|protected|public|readonly|require|require_once|return|self|static|switch|throw|trait|try|unset|use|var|while|xor|yield|__halt_compiler)\b/i, lookbehind: !0 }], 'argument-name': { pattern: /([(,]\s*)\b[a-z_]\w*(?=\s*:(?!:))/i, lookbehind: !0 }, 'class-name': [{ pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self|\s+static))\s+|\bcatch\s*\()\b[a-z_]\w*(?!\\)\b/i, greedy: !0, lookbehind: !0 }, { pattern: /(\|\s*)\b[a-z_]\w*(?!\\)\b/i, greedy: !0, lookbehind: !0 }, { pattern: /\b[a-z_]\w*(?!\\)\b(?=\s*\|)/i, greedy: !0 }, { pattern: /(\|\s*)(?:\\?\b[a-z_]\w*)+\b/i, alias: 'class-name-fully-qualified', greedy: !0, lookbehind: !0, inside: { punctuation: /\\/ } }, { pattern: /(?:\\?\b[a-z_]\w*)+\b(?=\s*\|)/i, alias: 'class-name-fully-qualified', greedy: !0, inside: { punctuation: /\\/ } }, { pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self\b|\s+static\b))\s+|\bcatch\s*\()(?:\\?\b[a-z_]\w*)+\b(?!\\)/i, alias: 'class-name-fully-qualified', greedy: !0, lookbehind: !0, inside: { punctuation: /\\/ } }, { pattern: /\b[a-z_]\w*(?=\s*\$)/i, alias: 'type-declaration', greedy: !0 }, { pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i, alias: ['class-name-fully-qualified', 'type-declaration'], greedy: !0, inside: { punctuation: /\\/ } }, { pattern: /\b[a-z_]\w*(?=\s*::)/i, alias: 'static-context', greedy: !0 }, { pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*::)/i, alias: ['class-name-fully-qualified', 'static-context'], greedy: !0, inside: { punctuation: /\\/ } }, { pattern: /([(,?]\s*)[a-z_]\w*(?=\s*\$)/i, alias: 'type-hint', greedy: !0, lookbehind: !0 }, { pattern: /([(,?]\s*)(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i, alias: ['class-name-fully-qualified', 'type-hint'], greedy: !0, lookbehind: !0, inside: { punctuation: /\\/ } }, { pattern: /(\)\s*:\s*(?:\?\s*)?)\b[a-z_]\w*(?!\\)\b/i, alias: 'return-type', greedy: !0, lookbehind: !0 }, { pattern: /(\)\s*:\s*(?:\?\s*)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i, alias: ['class-name-fully-qualified', 'return-type'], greedy: !0, lookbehind: !0, inside: { punctuation: /\\/ } }], constant: t, function: { pattern: /(^|[^\\\w])\\?[a-z_](?:[\w\\]*\w)?(?=\s*\()/i, lookbehind: !0, inside: { punctuation: /\\/ } }, property: { pattern: /(->\s*)\w+/, lookbehind: !0 }, number: i, operator: n, punctuation: s,
    }; const l = { pattern: /\{\$(?:\{(?:\{[^{}]+\}|[^{}]+)\}|[^{}])+\}|(^|[^\\{])\$+(?:\w+(?:\[[^\r\n\[\]]+\]|->\w+)?)/, lookbehind: !0, inside: e.languages.php }; const r = [{ pattern: /<<<'([^']+)'[\r\n](?:.*[\r\n])*?\1;/, alias: 'nowdoc-string', greedy: !0, inside: { delimiter: { pattern: /^<<<'[^']+'|[a-z_]\w*;$/i, alias: 'symbol', inside: { punctuation: /^<<<'?|[';]$/ } } } }, { pattern: /<<<(?:"([^"]+)"[\r\n](?:.*[\r\n])*?\1;|([a-z_]\w*)[\r\n](?:.*[\r\n])*?\2;)/i, alias: 'heredoc-string', greedy: !0, inside: { delimiter: { pattern: /^<<<(?:"[^"]+"|[a-z_]\w*)|[a-z_]\w*;$/i, alias: 'symbol', inside: { punctuation: /^<<<"?|[";]$/ } }, interpolation: l } }, { pattern: /`(?:\\[\s\S]|[^\\`])*`/, alias: 'backtick-quoted-string', greedy: !0 }, { pattern: /'(?:\\[\s\S]|[^\\'])*'/, alias: 'single-quoted-string', greedy: !0 }, { pattern: /"(?:\\[\s\S]|[^\\"])*"/, alias: 'double-quoted-string', greedy: !0, inside: { interpolation: l } }]; e.languages.insertBefore('php', 'variable', {
      string: r,
      attribute: {
        pattern: /#\[(?:[^"'\/#]|\/(?![*/])|\/\/.*$|#(?!\[).*$|\/\*(?:[^*]|\*(?!\/))*\*\/|"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*')+\](?=\s*[a-z$#])/im,
        greedy: !0,
        inside: {
          'attribute-content': {
            pattern: /^(#\[)[\s\S]+(?=\]$)/,
            lookbehind: !0,
            inside: {
              comment: a, string: r, 'attribute-class-name': [{ pattern: /([^:]|^)\b[a-z_]\w*(?!\\)\b/i, alias: 'class-name', greedy: !0, lookbehind: !0 }, { pattern: /([^:]|^)(?:\\?\b[a-z_]\w*)+/i, alias: ['class-name', 'class-name-fully-qualified'], greedy: !0, lookbehind: !0, inside: { punctuation: /\\/ } }], constant: t, number: i, operator: n, punctuation: s,
            },
          },
          delimiter: { pattern: /^#\[|\]$/, alias: 'punctuation' },
        },
      },
    }), e.hooks.add('before-tokenize', ((a) => { /<\?/.test(a.code) && e.languages['markup-templating'].buildPlaceholders(a, 'php', /<\?(?:[^"'/#]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|(?:\/\/|#(?!\[))(?:[^?\n\r]|\?(?!>))*(?=$|\?>|[\r\n])|#\[|\/\*(?:[^*]|\*(?!\/))*(?:\*\/|$))*?(?:\?>|$)/g); })), e.hooks.add('after-tokenize', ((a) => { e.languages['markup-templating'].tokenizePlaceholders(a, 'php'); }));
  }(Prism));
  Prism.languages.sql = {
    comment: { pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/, lookbehind: !0 }, variable: [{ pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/, greedy: !0 }, /@[\w.$]+/], string: { pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/, greedy: !0, lookbehind: !0 }, identifier: { pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/, greedy: !0, lookbehind: !0, inside: { punctuation: /^`|`$/ } }, function: /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i, keyword: /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i, boolean: /\b(?:FALSE|NULL|TRUE)\b/i, number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i, operator: /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i, punctuation: /[;[\]()`,.]/,
  };
  !(function () { if (typeof Prism !== 'undefined' && typeof document !== 'undefined') { const e = 'line-numbers'; var n = /\n(?!$)/g; const t = Prism.plugins.lineNumbers = { getLine(n, t) { if (n.tagName === 'PRE' && n.classList.contains(e)) { const i = n.querySelector('.line-numbers-rows'); if (i) { const r = parseInt(n.getAttribute('data-start'), 10) || 1; const s = r + (i.children.length - 1); t < r && (t = r), t > s && (t = s); const l = t - r; return i.children[l]; } } }, resize(e) { r([e]); }, assumeViewportIndependence: !0 }; let i = void 0; window.addEventListener('resize', (() => { t.assumeViewportIndependence && i === window.innerWidth || (i = window.innerWidth, r(Array.prototype.slice.call(document.querySelectorAll('pre.line-numbers')))); })), Prism.hooks.add('complete', ((t) => { if (t.code) { const i = t.element; const s = i.parentNode; if (s && /pre/i.test(s.nodeName) && !i.querySelector('.line-numbers-rows') && Prism.util.isActive(i, e)) { i.classList.remove(e), s.classList.add(e); let l; const o = t.code.match(n); const a = o ? o.length + 1 : 1; const u = new Array(a + 1).join('<span></span>'); (l = document.createElement('span')).setAttribute('aria-hidden', 'true'), l.className = 'line-numbers-rows', l.innerHTML = u, s.hasAttribute('data-start') && (s.style.counterReset = `linenumber ${parseInt(s.getAttribute('data-start'), 10) - 1}`), t.element.appendChild(l), r([s]), Prism.hooks.run('line-numbers', t); } } })), Prism.hooks.add('line-numbers', ((e) => { e.plugins = e.plugins || {}, e.plugins.lineNumbers = !0; })); } function r(e) { if ((e = e.filter(((e) => { let n; const t = (n = e, n ? window.getComputedStyle ? getComputedStyle(n) : n.currentStyle || null : null)['white-space']; return t === 'pre-wrap' || t === 'pre-line'; }))).length != 0) { const t = e.map(((e) => { const t = e.querySelector('code'); const i = e.querySelector('.line-numbers-rows'); if (t && i) { let r = e.querySelector('.line-numbers-sizer'); const s = t.textContent.split(n); r || ((r = document.createElement('span')).className = 'line-numbers-sizer', t.appendChild(r)), r.innerHTML = '0', r.style.display = 'block'; const l = r.getBoundingClientRect().height; return r.innerHTML = '', { element: e, lines: s, lineHeights: [], oneLinerHeight: l, sizer: r }; } })).filter(Boolean); t.forEach(((e) => { const n = e.sizer; const t = e.lines; const i = e.lineHeights; const r = e.oneLinerHeight; i[t.length - 1] = void 0, t.forEach(((e, t) => { if (e && e.length > 1) { const s = n.appendChild(document.createElement('span')); s.style.display = 'block', s.textContent = e; } else i[t] = r; })); })), t.forEach(((e) => { for (let n = e.sizer, t = e.lineHeights, i = 0, r = 0; r < t.length; r++) void 0 === t[r] && (t[r] = n.children[i++].getBoundingClientRect().height); })), t.forEach(((e) => { const n = e.sizer; const t = e.element.querySelector('.line-numbers-rows'); n.style.display = 'none', n.innerHTML = '', e.lineHeights.forEach(((e, n) => { t.children[n].style.height = `${e}px`; })); })); } } }());
  typeof Prism !== 'undefined' && typeof document !== 'undefined' && document.createRange && (Prism.plugins.KeepMarkup = !0, Prism.hooks.add('before-highlight', ((e) => { if (e.element.children.length && Prism.util.isActive(e.element, 'keep-markup', !0)) { var n = Prism.util.isActive(e.element, 'drop-tokens', !1); var t = 0; var o = []; r(e.element), o.length && (e.keepMarkup = o); } function d(e) { if (function (e) { return !n || e.nodeName.toLowerCase() !== 'span' || !e.classList.contains('token'); }(e)) { const d = { element: e, posOpen: t }; o.push(d), r(e), d.posClose = t; } else r(e); } function r(e) { for (let n = 0, o = e.childNodes.length; n < o; n++) { const r = e.childNodes[n]; r.nodeType === 1 ? d(r) : r.nodeType === 3 && (t += r.data.length); } } })), Prism.hooks.add('after-highlight', ((e) => { if (e.keepMarkup && e.keepMarkup.length) { var n = function (e, t) { for (let o = 0, d = e.childNodes.length; o < d; o++) { const r = e.childNodes[o]; if (r.nodeType === 1) { if (!n(r, t)) return !1; } else r.nodeType === 3 && (!t.nodeStart && t.pos + r.data.length > t.node.posOpen && (t.nodeStart = r, t.nodeStartPos = t.node.posOpen - t.pos), t.nodeStart && t.pos + r.data.length >= t.node.posClose && (t.nodeEnd = r, t.nodeEndPos = t.node.posClose - t.pos), t.pos += r.data.length); if (t.nodeStart && t.nodeEnd) { const s = document.createRange(); return s.setStart(t.nodeStart, t.nodeStartPos), s.setEnd(t.nodeEnd, t.nodeEndPos), t.node.element.innerHTML = '', t.node.element.appendChild(s.extractContents()), s.insertNode(t.node.element), s.detach(), !1; } } return !0; }; e.keepMarkup.forEach(((t) => { n(e.element, { node: t, pos: 0 }); })), e.highlightedCode = e.element.innerHTML; } })));
  !(function () {
    if (typeof Prism !== 'undefined') {
      const e = Object.assign || function (e, t) { for (const n in t)t.hasOwnProperty(n) && (e[n] = t[n]); return e; }; const t = {
        'remove-trailing': 'boolean', 'remove-indent': 'boolean', 'left-trim': 'boolean', 'right-trim': 'boolean', 'break-lines': 'number', indent: 'number', 'remove-initial-line-feed': 'boolean', 'tabs-to-spaces': 'number', 'spaces-to-tabs': 'number',
      }; n.prototype = {
        setDefaults(t) { this.defaults = e(this.defaults, t); }, normalize(t, n) { for (const r in n = e(this.defaults, n)) { const i = r.replace(/-(\w)/g, ((e, t) => t.toUpperCase())); r !== 'normalize' && i !== 'setDefaults' && n[r] && this[i] && (t = this[i].call(this, t, n[r])); } return t; }, leftTrim(e) { return e.replace(/^\s+/, ''); }, rightTrim(e) { return e.replace(/\s+$/, ''); }, tabsToSpaces(e, t) { return t = 0 | t || 4, e.replace(/\t/g, new Array(++t).join(' ')); }, spacesToTabs(e, t) { return t = 0 | t || 4, e.replace(RegExp(` {${t}}`, 'g'), '\t'); }, removeTrailing(e) { return e.replace(/\s*?$/gm, ''); }, removeInitialLineFeed(e) { return e.replace(/^(?:\r?\n|\r)/, ''); }, removeIndent(e) { const t = e.match(/^[^\S\n\r]*(?=\S)/gm); return t && t[0].length ? (t.sort(((e, t) => e.length - t.length)), t[0].length ? e.replace(RegExp(`^${t[0]}`, 'gm'), '') : e) : e; }, indent(e, t) { return e.replace(/^[^\S\n\r]*(?=\S)/gm, `${new Array(++t).join('\t')}$&`); }, breakLines(e, t) { t = !0 === t ? 80 : 0 | t || 80; for (var n = e.split('\n'), i = 0; i < n.length; ++i) if (!(r(n[i]) <= t)) { for (var o = n[i].split(/(\s+)/g), a = 0, l = 0; l < o.length; ++l) { const s = r(o[l]); (a += s) > t && (o[l] = `\n${o[l]}`, a = s); }n[i] = o.join(''); } return n.join('\n'); },
      }, typeof module !== 'undefined' && module.exports && (module.exports = n), Prism.plugins.NormalizeWhitespace = new n({ 'remove-trailing': !0, 'remove-indent': !0, 'left-trim': !0, 'right-trim': !0 }), Prism.hooks.add('before-sanity-check', ((e) => { const n = Prism.plugins.NormalizeWhitespace; if ((!e.settings || !1 !== e.settings['whitespace-normalization']) && Prism.util.isActive(e.element, 'whitespace-normalization', !0)) if (e.element && e.element.parentNode || !e.code) { const r = e.element.parentNode; if (e.code && r && r.nodeName.toLowerCase() === 'pre') { for (const i in e.settings == null && (e.settings = {}), t) if (Object.hasOwnProperty.call(t, i)) { const o = t[i]; if (r.hasAttribute(`data-${i}`)) try { const a = JSON.parse(r.getAttribute(`data-${i}`) || 'true'); typeof a === o && (e.settings[i] = a); } catch (e) {} } for (var l = r.childNodes, s = '', c = '', u = !1, m = 0; m < l.length; ++m) { const f = l[m]; f == e.element ? u = !0 : f.nodeName === '#text' && (u ? c += f.nodeValue : s += f.nodeValue, r.removeChild(f), --m); } if (e.element.children.length && Prism.plugins.KeepMarkup) { const d = s + e.element.innerHTML + c; e.element.innerHTML = n.normalize(d, e.settings), e.code = e.element.textContent; } else e.code = s + e.code + c, e.code = n.normalize(e.code, e.settings); } } else e.code = n.normalize(e.code, e.settings); }));
    } function n(t) { this.defaults = { ...t }; } function r(e) { for (var t = 0, n = 0; n < e.length; ++n)e.charCodeAt(n) == '\t'.charCodeAt(0) && (t += 3); return e.length + t; }
  }());
  !(function () { if (typeof Prism !== 'undefined' && typeof document !== 'undefined') { const e = []; const t = {}; const n = function () {}; Prism.plugins.toolbar = {}; const a = Prism.plugins.toolbar.registerButton = function (n, a) { let r; r = typeof a === 'function' ? a : function (e) { let t; return typeof a.onClick === 'function' ? ((t = document.createElement('button')).type = 'button', t.addEventListener('click', (function () { a.onClick.call(this, e); }))) : typeof a.url === 'string' ? (t = document.createElement('a')).href = a.url : t = document.createElement('span'), a.className && t.classList.add(a.className), t.textContent = a.text, t; }, n in t ? console.warn(`There is a button with the key "${n}" registered already.`) : e.push(t[n] = r); }; const r = Prism.plugins.toolbar.hook = function (a) { const r = a.element.parentNode; if (r && /pre/i.test(r.nodeName) && !r.parentNode.classList.contains('code-toolbar')) { const o = document.createElement('div'); o.classList.add('code-toolbar'), r.parentNode.insertBefore(o, r), o.appendChild(r); const i = document.createElement('div'); i.classList.add('toolbar'); let l = e; const d = (function (e) { for (;e;) { let t = e.getAttribute('data-toolbar-order'); if (t != null) return (t = t.trim()).length ? t.split(/\s*,\s*/g) : []; e = e.parentElement; } }(a.element)); d && (l = d.map(((e) => t[e] || n))), l.forEach(((e) => { const t = e(a); if (t) { const n = document.createElement('div'); n.classList.add('toolbar-item'), n.appendChild(t), i.appendChild(n); } })), o.appendChild(i); } }; a('label', ((e) => { const t = e.element.parentNode; if (t && /pre/i.test(t.nodeName) && t.hasAttribute('data-label')) { let n; let a; const r = t.getAttribute('data-label'); try { a = document.querySelector(`template#${r}`); } catch (e) {} return a ? n = a.content : (t.hasAttribute('data-url') ? (n = document.createElement('a')).href = t.getAttribute('data-url') : n = document.createElement('span'), n.textContent = r), n; } })), Prism.hooks.add('complete', r); } }());
  !(function () { function t(t) { const e = document.createElement('textarea'); e.value = t.getText(), e.style.top = '0', e.style.left = '0', e.style.position = 'fixed', document.body.appendChild(e), e.focus(), e.select(); try { const o = document.execCommand('copy'); setTimeout((() => { o ? t.success() : t.error(); }), 1); } catch (e) { setTimeout((() => { t.error(e); }), 1); }document.body.removeChild(e); } typeof Prism !== 'undefined' && typeof document !== 'undefined' && (Prism.plugins.toolbar ? Prism.plugins.toolbar.registerButton('copy-to-clipboard', ((e) => { const o = e.element; const n = (function (t) { const e = { copy: 'Copy', 'copy-error': 'Press Ctrl+C to copy', 'copy-success': 'Copied!', 'copy-timeout': 5e3 }; for (const o in e) { for (var n = `data-prismjs-${o}`, c = t; c && !c.hasAttribute(n);)c = c.parentElement; c && (e[o] = c.getAttribute(n)); } return e; }(o)); const c = document.createElement('button'); c.className = 'copy-to-clipboard-button', c.setAttribute('type', 'button'); const r = document.createElement('span'); return c.appendChild(r), u('copy'), (function (e, o) { e.addEventListener('click', (() => { !(function (e) { navigator.clipboard ? navigator.clipboard.writeText(e.getText()).then(e.success, (() => { t(e); })) : t(e); }(o)); })); }(c, { getText() { return o.textContent; }, success() { u('copy-success'), i(); }, error() { u('copy-error'), setTimeout((() => { !(function (t) { window.getSelection().selectAllChildren(t); }(o)); }), 1), i(); } })), c; function i() { setTimeout((() => { u('copy'); }), n['copy-timeout']); } function u(t) { r.textContent = n[t], c.setAttribute('data-copy-state', t); } })) : console.warn('Copy to Clipboard plugin loaded before Toolbar plugin.')); }());
};

const getLanguage = (lang) => {
  if (
    lang === 'language-as3'
        || lang === 'language-coldfusion'
        || lang === 'language-cpp'
        || lang === 'language-java'
        || lang === 'language-javascript'
  ) { return 'language-clike'; }
  if (lang === 'language-mxml') return 'language-xml';
  return lang;
};

export default (block) => {
  if (!window.Prism) {
    window.Prism = window.Prism || {};
    window.Prism.manual = true;
    initPrism();
  }
  const pre = block.querySelector('pre');
  pre?.classList.add(getLanguage(block.classList[1]));
  const code = block.querySelector('code');
  if (code) {
    code.innerHTML = code.innerHTML
      .split('\n')
      .map((line, index, array) => `<div class="line">${line}${index === array.length - 1 ? '' : '\n'}</div>`)
      .join('');
  }
  window.Prism.highlightAllUnder(block);
};
